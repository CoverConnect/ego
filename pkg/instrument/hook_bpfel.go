// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64

package instrument

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type hookFunctionParameterListT struct {
	GoidOffset        uint32
	ParentGoidOffset  uint32
	G_addrOffset      int64
	GoroutineId       int32
	ParentGoroutineId int32
	FnAddr            uint64
	IsRet             bool
	_                 [3]byte
	N_parameters      uint32
	Params            [6]struct {
		Name     [10]int8
		_        [2]byte
		Size     uint32
		Offset   int32
		InReg    bool
		_        [3]byte
		Daddr    uint64
		Val      [48]int8
		DerefVal [48]int8
	}
	N_retParameters uint32
	_               [4]byte
	RetParams       [6]struct {
		Name     [10]int8
		_        [2]byte
		Size     uint32
		Offset   int32
		InReg    bool
		_        [3]byte
		Daddr    uint64
		Val      [48]int8
		DerefVal [48]int8
	}
	Ctx struct {
		FnAddr uint64
		R15    uint64
		R14    uint64
		R13    uint64
		R12    uint64
		Bp     uint64
		Bx     uint64
		R11    uint64
		R10    uint64
		R9     uint64
		R8     uint64
		Ax     uint64
		Cx     uint64
		Dx     uint64
		Si     uint64
		Di     uint64
		Ip     uint64
		Cs     uint64
		Flags  uint64
		Sp     uint64
		Ss     uint64
	}
}

// loadHook returns the embedded CollectionSpec for hook.
func loadHook() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_HookBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load hook: %w", err)
	}

	return spec, err
}

// loadHookObjects loads hook and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*hookObjects
//	*hookPrograms
//	*hookMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadHookObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadHook()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// hookSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hookSpecs struct {
	hookProgramSpecs
	hookMapSpecs
}

// hookSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hookProgramSpecs struct {
	UprobeHook *ebpf.ProgramSpec `ebpf:"uprobe_hook"`
}

// hookMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hookMapSpecs struct {
	ContextMap     *ebpf.MapSpec `ebpf:"context_map"`
	ProbeTimeEvent *ebpf.MapSpec `ebpf:"probe_time_event"`
}

// hookObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadHookObjects or ebpf.CollectionSpec.LoadAndAssign.
type hookObjects struct {
	hookPrograms
	hookMaps
}

func (o *hookObjects) Close() error {
	return _HookClose(
		&o.hookPrograms,
		&o.hookMaps,
	)
}

// hookMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadHookObjects or ebpf.CollectionSpec.LoadAndAssign.
type hookMaps struct {
	ContextMap     *ebpf.Map `ebpf:"context_map"`
	ProbeTimeEvent *ebpf.Map `ebpf:"probe_time_event"`
}

func (m *hookMaps) Close() error {
	return _HookClose(
		m.ContextMap,
		m.ProbeTimeEvent,
	)
}

// hookPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadHookObjects or ebpf.CollectionSpec.LoadAndAssign.
type hookPrograms struct {
	UprobeHook *ebpf.Program `ebpf:"uprobe_hook"`
}

func (p *hookPrograms) Close() error {
	return _HookClose(
		p.UprobeHook,
	)
}

func _HookClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed hook_bpfel.o
var _HookBytes []byte

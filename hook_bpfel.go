// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || amd64p32 || arm || arm64 || loong64 || mips64le || mips64p32le || mipsle || ppc64le || riscv64

package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type hookFunctionContextT struct {
	FnAddr uint64
	R15    uint64
	R14    uint64
	R13    uint64
	R12    uint64
	Bp     uint64
	Bx     uint64
	R11    uint64
	R10    uint64
	R9     uint64
	R8     uint64
	Ax     uint64
	Cx     uint64
	Dx     uint64
	Si     uint64
	Di     uint64
	Ip     uint64
	Cs     uint64
	Flags  uint64
	Sp     uint64
	Ss     uint64
}

// loadHook returns the embedded CollectionSpec for hook.
func loadHook() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_HookBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load hook: %w", err)
	}

	return spec, err
}

// loadHookObjects loads hook and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*hookObjects
//	*hookPrograms
//	*hookMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadHookObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadHook()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// hookSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hookSpecs struct {
	hookProgramSpecs
	hookMapSpecs
}

// hookSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hookProgramSpecs struct {
	UprobeHook *ebpf.ProgramSpec `ebpf:"uprobe_hook"`
}

// hookMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type hookMapSpecs struct {
	ContextMap *ebpf.MapSpec `ebpf:"context_map"`
	Events     *ebpf.MapSpec `ebpf:"events"`
}

// hookObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadHookObjects or ebpf.CollectionSpec.LoadAndAssign.
type hookObjects struct {
	hookPrograms
	hookMaps
}

func (o *hookObjects) Close() error {
	return _HookClose(
		&o.hookPrograms,
		&o.hookMaps,
	)
}

// hookMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadHookObjects or ebpf.CollectionSpec.LoadAndAssign.
type hookMaps struct {
	ContextMap *ebpf.Map `ebpf:"context_map"`
	Events     *ebpf.Map `ebpf:"events"`
}

func (m *hookMaps) Close() error {
	return _HookClose(
		m.ContextMap,
		m.Events,
	)
}

// hookPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadHookObjects or ebpf.CollectionSpec.LoadAndAssign.
type hookPrograms struct {
	UprobeHook *ebpf.Program `ebpf:"uprobe_hook"`
}

func (p *hookPrograms) Close() error {
	return _HookClose(
		p.UprobeHook,
	)
}

func _HookClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed hook_bpfel.o
var _HookBytes []byte
